По 1 дз - если все понятно, то не читаем, если не понятно, то может, это вам поможетКака работать с  yargs в switch
Давайте с начала - в вашей домашней работе предполагается реализовать методы работы с файлом: чтение из него всех данных и вывод в консоль, добавление данных, удаление данных и поиск по id.
Но как мы можем вызвать ту или иную функцию на выполнение. Для этого нам надо как-то в скрипт передать данные.
Для этих целей используется модуль yargs
он позволяет передавать в виде аргументов данные, которые могут обрабатываться внутри вашего скрипта.
что бы просто запустить на выполнение код из файла в ноде надо написать node и название того файла который вы хотите запустить. В вашей дз это node index.js
 Но нам надо как-то передать в этот файл параметры, что бы можно было вызвать на выполнение конкретную функцию
 node index.js --action="list"
* вот тут происходит запуск файла index.js и передача аргумента --action="list"
как он будет обрабатываться в самом скрипте
сначала подключаем вначале файла нужный нам модуль - const argv = require('yargs').argv;   берем из него возможность работы с аргументами.
дальше создаем функцию которая принимает аргументы  - function invokeAction({ action, id, name, email, phone })
 и вызываем ее  - invokeAction(argv); -
если мы запустим наш скрпит с аргументами node index.js --action="list" - то в функцию попадает флаг --action со значением list
дальше управление передается на
switch (action) {
и тут будет происходить поиск
    case 'list':
      // ...
      break;
ответа со значением list
аналогично отработают все остальные action, которые вы передадите какждый раз запуская скрипт с разными аргументами
node index.js --action="get" --id=5# Добавялем контакт
node index.js --action="add" --name="Mango" --email="mango@gmail.com" --phone="322-22-22"# Удаляем контакт
node index.js --action="remove" --id=3
если вы попробуете вызвать ваш скрипт НЕ передав аргументы  - node index.js - вы попадете на ветку -
   default:
      console.warn('\x1B[31m Unknown action type!');
и увидите в консоли ошибку красного цвета - с сообщением, что это не известный вид action
Красный цвет обеспечивает  - \x1B[31m
Вот таким методом работает в связке argv и switch
что бы в простом виде посмотреть как это работает можете написать как-то так
 // index.js
const argv = require('yargs').argv;// TODO: рефакторить
function invokeAction({ action, id, name, email, phone }) {
  switch (action) {
    case 'list':
      console.log('list')
      break;    case 'get':
       console.log('id',id)
      break;    case 'add':
     console.log( 'name email phone', name, email, phone)
      break;    case 'remove':
      console.log('id',id)
      break;    default:
      console.warn('\x1B[31m Unknown action type!');
  }
}invokeAction(argv);
и запустите этот скрпит с предложенными вам методами
node index.js --action="list"# Получаем контакт по id
node index.js --action="get" --id=5# Добавялем контакт
node index.js --action="add" --name="Mango" --email="mango@gmail.com" --phone="322-22-22"# Удаляем контакт
node index.js --action="remove" --id=3
Ну а дальше вам надо прописывать методы в самом contact.js экспортировать их из файла и импортировать в файле index.js и вызывать их в соответствующих case
1
8:13
_____________________________________________________________________________
* разница path.resolve() и  path.join() , в дз надо использовать path.join()  а не path.resolve()  почему?
https://stackoverflow.com/a/45575007 - вот хорошее объяснение, не буду его тут перепечатывать. Но смысл в том, что path.resolve()  даст абсолютный путь  - для примера -
E:\MyFolder\Pjtz\node
* а вот теперь представляем ситуацию - мы с вами работаем в одной команде, все мы делаем часть общего проекта, все мы пушим в один репозиторий, и каждый разворачивает приложение у себя на компьютере. И вот с этого места, у всех, кроме автора кода - будут большие проблемы - потому что ваше приложение будет работать правильно ТОЛЬКО в том случае если у меня оно развернуто в директории E:\MyFolder\Pjtz\node .
_____________________________________________
* разница const fs = require('fs').promises и const fs = require('fs')
Изначально модуль написан с использованием call-back функций и вызывался через  const fs = request("fs")
Дальше js развивается и уже никто не пишет на call-back функциях, потому что это устаревший стиль и еще колл-бак ад. Тогда в модуль добавили поддержку промисов,  Теперь можно использовать функции, но работать с ними не через коллбаки, а через промисы.  Соответвенно надо подключить работу с промисами const fs = require('fs').promises
Сейчас уже работают, не через промисы, а через обвертку над промисами async /await. Это сокращает код и делает его более читабельным
Если собираетесь использовать колбеки, то подключаете библиотеку без промисов.Давайте поговорим о базовом JS
Что такое колбэки - "В функции, которые выполняют какие-либо асинхронные операции, передаётся аргумент callback — функция, которая будет вызвана по завершению асинхронного действия"
когда они используются? - когда есть «асинхронность» (когда какой-то процесс  будет завершен не сейчас, а потом)
function НазваниеФункции (аргументы, callback) {
 ......(какой-то код)
}
Теперь работа с самой функцией колбека
function НазваниеФункции (аргументы, function(error, data) {
  if (error) {
    // обрабатываем ошибку
  } else {
    // успешно выполнено
  }
});
такой подход называется «колбэк с первым аргументом-ошибкой» («error-first callback»).
Правила таковы:
1. Первый аргумент функции callback зарезервирован для ошибки. В этом случае вызов выглядит вот так: callback(err).
2. Второй и последующие аргументы — для результатов выполнения. В этом случае вызов выглядит вот так: callback(null, result1, result2…).
Одна и та же функция callback используется и для информирования об ошибке, и для передачи результатов.теперь то, как это выглядит применительно к вашей 1 дз и к первой функции
function listContacts() {
  fs.readFile(contactsPath, (err, data) => {
    if (err)  return console.error(err.message);
      console.table(JSON.parse(data.toString()));
  });
}
это если мы собираемся в основном файле просто вызвать функцию listContacts()Если вы хотите вернуть данные и уже в основном файле и обработать и вывести их в консоль, то
function listContacts() {  
fs.readFile(contactsPath, (err, data) => {    
if (err) return console.error(err.message);     
   return data;  
});  
return JSON.parse(list);
}
тогда в основном файле вы можете вызвать listContacts().then(data => console.table(data)______________________________________________________________________________
 Потом эволюция дошла до промисов,
const fs = require('fs').promises
1. Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
promise.then навешивает обработчики на успешный результат или ошибку
Если очередной then вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.
Если then возвращает промис, то до его выполнения может пройти некоторое время, оставшаяся часть цепочки будет ждать.
То есть, логика довольно проста:
* В каждом then мы получаем текущий результат работы.
* Можно его обработать синхронно и вернуть результат (например, применить JSON.parse). Или же, если нужна асинхронная обработка – инициировать её и вернуть промис.
При возникновении ошибки – она отправляется в ближайший обработчик onRejected.
Такой обработчик нужно поставить через второй аргумент .then(..., onRejected) или, что то же самое, через .catch(onRejected).
Чтобы поймать всевозможные ошибки, которые возникнут при загрузке и обработке данных, добавим catch в конец цепочки
promise.then(onFulfilled, onRejected)
пример первой функции з дз на чистых промисах
function listContacts() { 
readFile(contactsPath,'utf-8')
.then(data => console.log(JSON.parse(data))
    .catch(err => console.log(err))
}
Если собираемся вернуть данные в основной файл
function listContacts() { 
const list = readFile(contactsPath,'utf-8')
.then(data => return JSON.parse(data))
    .catch(err => console.log(err))
return list
}
_________________________________________________________________________________________Async/await
Существует специальный синтаксис для работы с промисами, который называется «async/await». Он удивительно прост для понимания и использования.
По сути, это просто «синтаксический сахар» для получения результата промиса, более наглядный, чем promise.then.
Что бы переписать функцию на промисах с помощью async/await:
1. Нам нужно заменить вызовы .then на await.
2. И добавить ключевое слово async перед объявлением функции.
async function listContacts() => {
  const res = await readFile(contactsPath);
  console.log(res)
}
Ошибки можно ловить, используя try..catch, как с обычным throw
В случае ошибки выполнение try прерывается и управление прыгает в начало блока catch. Блоком try можно обернуть несколько строк:
async function listContacts() {
  try {
    const data = await fs.readFile(contactsPath);
    const result = JSON.parse(data);
    console.table(result);
  } catch (error) {
    console.log(error);
  }
}
Если собираемся вернуть данные в основную функцию
async function listContacts() {
  try {
    const data = await fs.readFile(contactsPath);
    const result = JSON.parse(data);
     return result;  
  } catch (error) {
    console.log(error);
  }
}
Что дополнительно почитать:
https://habr.com/ru/company/skillbox/blog/458950/
8:13
_____________________________________________
На всякий случай давайте обсудим вот такой момент:
"добавление нового контакта, без метода push(). 
  function addContact(name, email, phone) {
 fs.readFile(contactsPath, { encoding: 'utf8' }, (err, data) => {
        if (err) { console.log(err.message) }
            const contacts = JSON.parse(data)
            const contactsNew = {id: shortid.generate(), name, email, phone }
            const contactsList = JSON.stringify([contactNew, ...contacts], null, '\t')            fs.writeFile(contactsPath, contactsList, (err) => { if (err) console.error(err) })
    })
  }
  try {
    addContact()
  } catch (error) {
    next(error)
  }
При классическом push(), вы ожидаете увидеть вот такого вида запись - const NewArr = contacts.push(contactNew)
- в примере сделали более элегантно -
"Использование оператора spread
Использование оператора spread не ограничивается передачей параметров функции. Несколько примеров его полезного использования:
Клонирование свойств массивов
var arr = ['will', 'love'];
var data = ['You', ...arr, 'spread', 'operator'];
console.log(data); // ['You', 'will', 'love', 'spread', 'operator']
"
http://jsraccoon.ru/es6-spread-rest
https://ru.hexlet.io/courses/js-arrays/lessons/spread-operator/theory_unitconst contactsList = JSON.stringify([
contactNew, ...contacts], null, '\t') - вот место, где делается спред вместо push()
8:14
_____________________________________________________________
Немного разбора кода по 1 дз
есть вот такой кусочек кода
try {
    const response = await fs.readFile(contactsPath, (err) => {
      if (err) return console.log(err.message);
    });
    let contacts = JSON.parse(response);
    return contacts;
  } catch (err) {
    console.error(err.message);
  }
* у тут применен стиль из колбек функций , async/await  и так же конструкция try/catch для отлова ошибок, - это избыточно.
Почему -
1)  Начнем с  if (err) return console.log(err.message); - тут спорная конструкция - console.log(err.message) - не может быть возвращен из  if  через директиву return, потому что будет выполнен, как только будет вызван, значит в return - ничего не попадет и в const response - будет присвоен - undefined. Итого, мы не получим ожидаемую ошибку, а получим в ответ undefined, который и вернём далее. Тут было бы правильней тогда просто вернуть ошибку if (err) return err.message;
Теперь у нас конструкция
try {
    const response = await fs.readFile(contactsPath, (err) => {
      if (err) return err.message;
    });
    let contacts = JSON.parse(response);
    return contacts;
  } catch (err) {
    console.error(err.message);
  }
2) fs.readFile(contactsPath, (err) => {
if (err) return err.message;
}); -  это колбек функция, потому что есть ожидание ответа, после того, как будет выполнена функция, и в функцию, которая возвращает значение, в данном примере мы ожидаем только ошибку - (err) => {
Но есть указание на директиву - await перед await fs.readFile - которая приведет к тому, что часть, которая относится к коллбек функции не будет выполнена и будет проигнорирована. Потому что если бы этот коллбек работал, то без явного возвращение из него значения response, в переменную const response ничего бы не присвоилось. То есть если бы тут работал коллбек, то функция должна была бы выглядеть вот так.
try {
    const response = await fs.readFile(contactsPath, (err, data) => {
      if (err) return err.message;
    return data;
    });
    let contacts = JSON.parse(response);
    return contacts;
  } catch (err) {
    console.error(err.message);
  }
Но по скольку происходит присвоение результата чтения файла в переменную -  const response = await fs.readFile(contactsPath, то это значит, что часть с колбеком просто игнорируется и значит обработка ошибки
 (err) => {
      if (err) return err.message;
    }
Никогда не будет вызвана и никогда не будет обрабатывать ошибку, и значит ее можно удалить. После сокращения наш код получится
try {
    const response = await fs.readFile(contactsPath);
    let contacts = JSON.parse(response);
    return contacts;
  } catch (err) {
    console.error(err.message);
  }

